<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>3D Keychain Text Preview</title>
  <style>
    body { margin: 0; overflow: hidden; background: #ffffff; }
    #preview { width: 100vw; height: 100vh; }
  </style>
</head>

<body>
<div id="preview"></div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/geometries/TextGeometry.js"></script>

<script>
let scene, camera, renderer, controls;
let keyGroup = null;
let loadedFont = null;
let interacted = false;

// -------- PROPER OUTLINE OFFSET (5mm) --------
const BORDER_OFFSET = 5;

function offsetShapePoints(points, offset) {
    const out = [];
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const n = points[(i + 1) % points.length];
        const dx = n.x - p.x;
        const dy = n.y - p.y;

        const len = Math.hypot(dx, dy) || 1;
        const nx = -dy / len;
        const ny = dx / len;

        out.push({ x: p.x + nx * offset, y: p.y + ny * offset });
    }
    return out;
}

function pointsToShape(points) {
    const shape = new THREE.Shape();
    shape.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) shape.lineTo(points[i].x, points[i].y);
    shape.lineTo(points[0].x, points[0].y);
    return shape;
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.set(0, 50, 200);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("preview").appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.addEventListener("start", () => interacted = true);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dl = new THREE.DirectionalLight(0xffffff, 0.8);
    dl.position.set(80, 100, 80);
    scene.add(dl);

    const fontLoader = new THREE.FontLoader();
    fontLoader.load(
        "https://gouthsi.github.io/keychain-3d/gill_sans_heavy.typeface.json",  // CHANGE THIS
        (font) => {
            loadedFont = font;
            buildKeychain("Your Name", "#ff0000", "#000000");
        }
    );

    window.addEventListener("resize", onResize);
    animate();
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function buildKeychain(text, topColor, baseColor) {
    if (!loadedFont) return;
    if (!text.trim()) text = "Your Name";

    if (keyGroup) {
        scene.remove(keyGroup);
        keyGroup.traverse(o => {
            if (o.geometry) o.geometry.dispose();
            if (o.material) o.material.dispose();
        });
    }

    keyGroup = new THREE.Group();

    const topHeight = 1.8;
    const baseHeight = 4;
    const fontSize = 20;

    // ---- Text geometry ----
    const textGeo = new THREE.TextGeometry(text, {
        font: loadedFont,
        size: fontSize,
        height: topHeight,
        bevelEnabled: true,
        bevelThickness: 0.32,
        bevelSize: 0.22,
        bevelSegments: 3,
        curveSegments: 8
    });

    textGeo.computeBoundingBox();
    const bb = textGeo.boundingBox;
    const textWidth = bb.max.x - bb.min.x;

    const cx = -(bb.max.x + bb.min.x) / 2;
    const cy = -(bb.max.y + bb.min.y) / 2;

    // auto-fit width
    const MAX_WIDTH = 150;
    const scaleFactor = MAX_WIDTH / textWidth;

    // TOP LAYER
    const topMat = new THREE.MeshPhongMaterial({ color: topColor });
    const topMesh = new THREE.Mesh(textGeo, topMat);
    topMesh.position.set(cx, cy, baseHeight);
    keyGroup.add(topMesh);

    // -------- REAL OUTLINE BASE (5mm) --------
    const rawShapes = loadedFont.generateShapes(text, fontSize);
    const outlineShapes = [];

    for (const s of rawShapes) {
        const pts = s.getPoints(8);
        const expanded = offsetShapePoints(pts, BORDER_OFFSET);
        outlineShapes.push(pointsToShape(expanded));
    }

    const baseGeo = new THREE.ExtrudeGeometry(outlineShapes, {
        depth: baseHeight,
        bevelEnabled: false,
        curveSegments: 8,
    });

    const baseMat = new THREE.MeshPhongMaterial({ color: baseColor });
    const baseMesh = new THREE.Mesh(baseGeo, baseMat);

    // CENTER BASE EXACTLY
    baseGeo.computeBoundingBox();
    const bbb = baseGeo.boundingBox;
    const bx = -(bbb.max.x + bbb.min.x) / 2;
    const by = -(bbb.max.y + bbb.min.y) / 2;

    baseMesh.position.set(bx, by, 0);
    keyGroup.add(baseMesh);

    // apply scale
    keyGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);

    // only tilt the ENTIRE GROUP (not layers individually)
    keyGroup.rotation.x = -0.22;

    scene.add(keyGroup);
}

window.onmessage = (e) => {
    const d = e.data || {};
    buildKeychain(
        d.text || "Your Name",
        d.topColor || "#ff0000",
        d.baseColor || "#000000"
    );
};

function animate() {
    requestAnimationFrame(animate);

    if (!interacted && keyGroup) keyGroup.rotation.y += 0.01;

    controls.update();
    renderer.render(scene, camera);
}

init();
</script>

</body>
</html>
