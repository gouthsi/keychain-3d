<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>3D Keychain Preview</title>
<style>
  body { margin: 0; overflow: hidden; background: #fff; }
  #preview { width: 100vw; height: 100vh; }
</style>
</head>

<body>
<div id="preview"></div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/geometries/TextGeometry.js"></script>

<!-- Clipper for boolean union + sharp outline -->
<script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>

<script>
let scene, camera, renderer, controls;
let keyGroup = null;
let loadedFont = null;
let interacted = false;

// Customizable
const BORDER_MM = 2;          // 2mm border
const SCALE_FACTOR = 20;      // Clipper scaling factor

//--------------------------------------------------------
// MERGE ALL LETTER SHAPES + OFFSET THEM (sharp corners)
//--------------------------------------------------------
function buildBaseOutline(rawShapes, borderMM) {

    const scale = SCALE_FACTOR;
    let allPaths = [];

    // 1) Convert all shapes to polygons
    rawShapes.forEach(sh => {
        const pts = sh.getPoints(40);
        const path = pts.map(p => ({
            X: Math.round(p.x * scale),
            Y: Math.round(p.y * scale)
        }));
        allPaths.push(path);
    });

    // 2) Boolean UNION → merge all letters into ONE shape
    let unionSolution = new ClipperLib.Paths();
    const clip = new ClipperLib.Clipper();

    clip.AddPaths(allPaths, ClipperLib.PolyType.ptSubject, true);
    clip.Execute(
        ClipperLib.ClipType.ctUnion,
        unionSolution,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero
    );

    // 3) OFFSET merged shape (sharp corners)
    const co = new ClipperLib.ClipperOffset(2, 1);
    co.MiterLimit = 20;

    co.AddPaths(
        unionSolution, 
        ClipperLib.JoinType.jtMiter,    // Miter = sharp corners
        ClipperLib.EndType.etClosedPolygon
    );

    let offsetSolution = new ClipperLib.Paths();
    co.Execute(offsetSolution, borderMM * scale);

    // 4) Convert back to Three.js Shape[] array
    let outShapes = [];
    offsetSolution.forEach(poly => {
        const pts = poly.map(p =>
            new THREE.Vector2(p.X / scale, p.Y / scale)
        );
        outShapes.push(new THREE.Shape(pts));
    });

    return outShapes;
}

//--------------------------------------------------------
// SCENE SETUP
//--------------------------------------------------------
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.set(0, 60, 200);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("preview").appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.addEventListener("start", () => interacted = true);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    const d1 = new THREE.DirectionalLight(0xffffff, 0.9);
    d1.position.set(80, 120, 100);
    scene.add(d1);

    // LOAD FONT
    const loader = new THREE.FontLoader();
    loader.load(
        "https://gouthsi.github.io/REPO/gill_sans_heavy.typeface.json",   // ← CHANGE THIS ONLY
        font => {
            loadedFont = font;
            buildKeychain("Your Name", "#ff0000", "#000000");
        }
    );

    window.addEventListener("resize", onResize);
    animate();
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

//--------------------------------------------------------
// BUILD THE KEYCHAIN MODEL
//--------------------------------------------------------
function buildKeychain(text, topColor, baseColor) {
    if (!loadedFont) return;

    if (keyGroup) {
        scene.remove(keyGroup);
        keyGroup.traverse(o => {
            if (o.geometry) o.geometry.dispose();
            if (o.material) o.material.dispose();
        });
    }

    keyGroup = new THREE.Group();

    const topHeight  = 1.8;
    const baseHeight = 4;
    const fontSize   = 20;

    //--------------------------------------------------------
    // TOP TEXT
    //--------------------------------------------------------
    const textGeo = new THREE.TextGeometry(text, {
        font: loadedFont,
        size: fontSize,
        height: topHeight,
        bevelEnabled: true,
        bevelThickness: 0.3,
        bevelSize: 0.22,
        bevelSegments: 3,
        curveSegments: 10
    });

    textGeo.computeBoundingBox();
    const bb = textGeo.boundingBox;
    const width = bb.max.x - bb.min.x;

    // center text
    const cx = -(bb.max.x + bb.min.x) / 2;
    const cy = -(bb.max.y + bb.min.y) / 2;

    // auto-fit to width
    const MAX_W = 150;
    const scaleFactor = MAX_W / width;

    const topMesh = new THREE.Mesh(
        textGeo,
        new THREE.MeshPhongMaterial({ color: topColor })
    );
    topMesh.position.set(cx, cy, baseHeight);
    keyGroup.add(topMesh);

    //--------------------------------------------------------
    // BASE LAYER — MERGED + OFFSET OUTLINE
    //--------------------------------------------------------
    const rawShapes = loadedFont.generateShapes(text, fontSize);
    const baseShapes = buildBaseOutline(rawShapes, BORDER_MM);

    // extrude base
    const baseGeo = new THREE.ExtrudeGeometry(baseShapes, {
        depth: baseHeight,
        bevelEnabled: false,
        curveSegments: 10
    });

    const baseMesh = new THREE.Mesh(
        baseGeo,
        new THREE.MeshPhongMaterial({ color: baseColor })
    );

    baseGeo.computeBoundingBox();
    const bbb = baseGeo.boundingBox;

    const bx = -(bbb.max.x + bbb.min.x) / 2;
    const by = -(bbb.max.y + bbb.min.y) / 2;

    baseMesh.position.set(bx, by, 0);
    keyGroup.add(baseMesh);

    //--------------------------------------------------------
    // SCALE + PLACE IN SCENE
    //--------------------------------------------------------
    keyGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
    keyGroup.rotation.x = -0.22;

    scene.add(keyGroup);
}

//--------------------------------------------------------
window.onmessage = (e) => {
    const d = e.data;
    buildKeychain(
        d.text || "Your Name",
        d.topColor || "#ff0000",
        d.baseColor || "#000000"
    );
};

function animate() {
    requestAnimationFrame(animate);

    if (!interacted && keyGroup)
        keyGroup.rotation.y += 0.01;

    controls.update();
    renderer.render(scene, camera);
}

init();
</script>

</body>
</html>
