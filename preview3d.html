<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>3D Keychain Text Preview</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #ffffff;
    }
    #preview {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="preview"></div>

  <!-- Three.js (CORS-safe from jsDelivr) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/geometries/TextGeometry.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let keychainGroup = null;
    let loadedFont = null;
    let userInteracted = false;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, aspect, 1, 2000);
      camera.position.set(0, 70, 220);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("preview").appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.addEventListener("start", () => {
        userInteracted = true; // stop auto-rotate when user touches
      });

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir1 = new THREE.DirectionalLight(0xffffff, 0.8);
      dir1.position.set(80, 120, 100);
      scene.add(dir1);

      const dir2 = new THREE.DirectionalLight(0xffffff, 0.4);
      dir2.position.set(-60, -80, -40);
      scene.add(dir2);

      // Load YOUR Gill Sans font (typeface.json)
      const loader = new THREE.FontLoader();
      loader.load(
        "https://gouthsi.github.io/keychain-3d/gill_sans_heavy.typeface.json",  // <-- CHANGE THIS
        (font) => {
          loadedFont = font;
          buildKeychain("Your Name", "#ff0000", "#000000");
        }
      );

      window.addEventListener("resize", onWindowResize);
      animate();
    }

    function onWindowResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    /**
     * text      = customer name
     * topColor  = color of raised text
     * baseColor = color of offset base behind text
     */
    function buildKeychain(text, topColor, baseColor) {
      if (!loadedFont) return;
      if (!text || text.trim().length === 0) text = "Your Name";

      // Remove previous group
      if (keychainGroup) {
        scene.remove(keychainGroup);
        keychainGroup.traverse((obj) => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
      }

      keychainGroup = new THREE.Group();

      // Base text geometry settings
      const baseSize = 20;     // font size before scaling
      const topHeight = 3;     // text layer thickness
      const baseHeight = 4;    // base layer thickness (slightly thicker)

      const textGeo = new THREE.TextGeometry(text, {
        font: loadedFont,
        size: baseSize,
        height: topHeight,
        bevelEnabled: true,
        bevelThickness: 1.2,
        bevelSize: 0.9,
        bevelSegments: 6,
        curveSegments: 10,
      });

      textGeo.computeBoundingBox();
      const bb = textGeo.boundingBox;
      const textWidth = bb.max.x - bb.min.x;
      const textHeight = bb.max.y - bb.min.y;

      // Centering offsets
      const xCenterOffset = - (bb.max.x + bb.min.x) / 2;
      const yCenterOffset = - (bb.max.y + bb.min.y) / 2;

      // Auto-fit: scale long names down to target width
      const TARGET_WIDTH = 160;  // adjust for your typical name length
      let scaleFactor = 1.0;
      if (textWidth > 0) {
        scaleFactor = TARGET_WIDTH / textWidth;
      }

      // --- TOP TEXT LAYER (raised) ---
      const topMat = new THREE.MeshPhongMaterial({ color: topColor });
      const topMesh = new THREE.Mesh(textGeo, topMat);
      topMesh.position.set(xCenterOffset, yCenterOffset, baseHeight / 2); // sits on base
      keychainGroup.add(topMesh);

      // --- BASE LAYER (offset silhouette) ---
      const baseGeo = textGeo.clone();
      const baseMat = new THREE.MeshPhongMaterial({ color: baseColor });
      const baseMesh = new THREE.Mesh(baseGeo, baseMat);

      // Slightly larger + offset in XY + a bit behind in Z
      const BASE_SCALE = 1.15; // how much bigger the outline is than text
      baseMesh.scale.set(BASE_SCALE, BASE_SCALE, baseHeight / topHeight);
      baseMesh.position.set(
        xCenterOffset + 1.5,         // slight x offset
        yCenterOffset - 1.5,         // slight y offset
        -baseHeight / 2              // behind
      );
      keychainGroup.add(baseMesh);

      // Apply overall scaling
      keychainGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);

      // Tilt and center a bit
      keychainGroup.rotation.x = -0.35;
      keychainGroup.position.set(0, 0, 0);

      scene.add(keychainGroup);
    }

    // Receive data from Wix (via postMessage)
    window.onmessage = (e) => {
      const d = e.data || {};
      buildKeychain(
        d.text || "Your Name",
        d.topColor || "#ff0000",
        d.baseColor || "#000000"
      );
    };

    function animate() {
      requestAnimationFrame(animate);

      // Auto-rotate until user interacts
      if (!userInteracted && keychainGroup) {
        keychainGroup.rotation.y += 0.01;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
