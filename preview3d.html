<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>3D Keychain Preview</title>
<style>
  body { margin: 0; overflow: hidden; background: #fff; }
  #preview { width: 100vw; height: 100vh; }
</style>
</head>

<body>
<div id="preview"></div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/geometries/TextGeometry.js"></script>

<!-- Clipper (boolean union + miter offset) -->
<script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>

<script>
let scene, camera, renderer, controls;
let keyGroup = null;
let loadedFont = null;
let interacted = false;

const BORDER_MM = 2;  
const SCALE_FACTOR = 20;

// ===============================
// BUILD MERGED OUTLINE
// ===============================
function buildBaseOutline(rawShapes, borderMM) {

    let allPaths = [];

    rawShapes.forEach(sh => {
        const pts = sh.getPoints(40);
        const path = pts.map(p => ({
            X: Math.round(p.x * SCALE_FACTOR),
            Y: Math.round(p.y * SCALE_FACTOR)
        }));
        allPaths.push(path);
    });

    // UNION
    const c = new ClipperLib.Clipper();
    let unionSolution = new ClipperLib.Paths();

    c.AddPaths(allPaths, ClipperLib.PolyType.ptSubject, true);
    c.Execute(
        ClipperLib.ClipType.ctUnion,
        unionSolution,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero
    );

    // OFFSET
    const co = new ClipperLib.ClipperOffset(2, 1);
    co.MiterLimit = 20;

    co.AddPaths(
        unionSolution,
        ClipperLib.JoinType.jtMiter,
        ClipperLib.EndType.etClosedPolygon
    );

    let expandedPaths = new ClipperLib.Paths();
    co.Execute(expandedPaths, borderMM * SCALE_FACTOR);

    // Convert back to shapes
    let shapesOut = [];

    expandedPaths.forEach(poly => {
        const pts = poly.map(p =>
            new THREE.Vector2(p.X / SCALE_FACTOR, p.Y / SCALE_FACTOR)
        );
        shapesOut.push(new THREE.Shape(pts));
    });

    return shapesOut;
}

// ===============================
// SCENE
// ===============================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 2000);
    camera.position.set(0, 60, 200);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("preview").appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    controls.addEventListener("start", () => interacted = true);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const d1 = new THREE.DirectionalLight(0xffffff, 0.9);
    d1.position.set(80, 120, 100);
    scene.add(d1);

    const loader = new THREE.FontLoader();
    loader.load(
        "https://gouths.github.io/keychain-3d/gill_sans_heavy.typeface.json",  // CHANGE
        f => {
            loadedFont = f;
            buildKeychain("Your Name", "#ff0000", "#000000");
        }
    );

    window.addEventListener("resize", onResize);
    animate();
}

function onResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ===============================
// BUILD KEYCHAIN
// ===============================
function buildKeychain(text, topColor, baseColor) {

    if (!loadedFont) return;

    if (keyGroup) {
        scene.remove(keyGroup);
        keyGroup.traverse(o => {
            if (o.geometry) o.geometry.dispose();
            if (o.material) o.material.dispose();
        });
    }

    keyGroup = new THREE.Group();

    const topH  = 1.8;
    const baseH = 4;
    const fontSize = 20;

    // TOP TEXT
    const textGeo = new THREE.TextGeometry(text, {
        font: loadedFont,
        size: fontSize,
        height: topH,
        bevelEnabled: true,
        bevelThickness: 0.3,
        bevelSize: 0.22,
        bevelSegments: 3,
        curveSegments: 10
    });

    textGeo.computeBoundingBox();
    const bb = textGeo.boundingBox;

    const w = bb.max.x - bb.min.x;
    const cx = -(bb.max.x + bb.min.x) / 2;
    const cy = -(bb.max.y + bb.min.y) / 2;

    const MAX_W = 150;
    const scaleFactor = MAX_W / w;

    const topMesh = new THREE.Mesh(
        textGeo,
        new THREE.MeshPhongMaterial({ color: topColor })
    );
    topMesh.position.set(cx, cy, baseH);
    keyGroup.add(topMesh);

    // BASE OUTLINE (MERGED)
    const rawShapes = loadedFont.generateShapes(text, fontSize);
    const baseShapes = buildBaseOutline(rawShapes, BORDER_MM);

    const baseGeo = new THREE.ExtrudeGeometry(baseShapes, {
        depth: baseH,
        bevelEnabled: false,
        curveSegments: 10
    });

    const baseMesh = new THREE.Mesh(
        baseGeo,
        new THREE.MeshPhongMaterial({ color: baseColor })
    );

    baseGeo.computeBoundingBox();
    const bb2 = baseGeo.boundingBox;

    const bx = -(bb2.max.x + bb2.min.x) / 2;
    const by = -(bb2.max.y + bb2.min.y) / 2;

    baseMesh.position.set(bx, by, 0);
    keyGroup.add(baseMesh);

    keyGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
    keyGroup.rotation.x = -0.22;

    scene.add(keyGroup);
}

// ===============================
window.onmessage = (e) => {
    const d = e.data;
    buildKeychain(d.text, d.topColor, d.baseColor);
};

function animate() {
    requestAnimationFrame(animate);

    if (!interacted && keyGroup)
        keyGroup.rotation.y += 0.01;

    controls.update();
    renderer.render(scene, camera);
}

init();
</script>

</body>
</html>

