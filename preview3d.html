<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>3D Keychain Preview</title>
<style>
  body { margin: 0; overflow: hidden; background: #fff; }
  #preview { width: 100vw; height: 100vh; }
</style>
</head>

<body>
<div id="preview"></div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/geometries/TextGeometry.js"></script>

<!-- Clipper (for real offset with sharp corners) -->
<script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>

<script>
let scene, camera, renderer, controls;
let keyGroup = null;
let loadedFont = null;
let interacted = false;

const BORDER_MM = 2;           // border thickness
const SCALE_FACTOR = 20;       // higher = more precision for outline

// -------------------------------------------------------
// TRUE sharp-corner OUTLINE using ClipperOffset (jtMiter)
// -------------------------------------------------------
function createOutlineShapes(shape, offsetAmount) {
    const pts = shape.getPoints(32);

    // convert to clipper integer coords
    const path = pts.map(p => ({
        X: Math.round(p.x * SCALE_FACTOR),
        Y: Math.round(p.y * SCALE_FACTOR)
    }));

    const co = new ClipperLib.ClipperOffset(2, 1);

    // SHARP MITER CORNERS
    co.MiterLimit = 20;  
    co.AddPath(
        path,
        ClipperLib.JoinType.jtMiter,          // SHARP CORNERS
        ClipperLib.EndType.etClosedPolygon
    );

    // execute offset
    const solution = new ClipperLib.Paths();
    co.Execute(solution, offsetAmount * SCALE_FACTOR);

    const shapes = [];
    solution.forEach(s => {
        const newPts = s.map(p =>
            new THREE.Vector2(
                p.X / SCALE_FACTOR,
                p.Y / SCALE_FACTOR
            )
        );
        shapes.push(new THREE.Shape(newPts));
    });

    return shapes;
}

// -------------------------------------------------------
// INIT SCENE
// -------------------------------------------------------
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(
        45, window.innerWidth / window.innerHeight, 1, 2000
    );
    camera.position.set(0, 60, 200);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("preview").appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.addEventListener("start", () => interacted = true);

    // lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    const d1 = new THREE.DirectionalLight(0xffffff, 0.9);
    d1.position.set(80, 110, 100);
    scene.add(d1);

    // load font
    const loader = new THREE.FontLoader();
    loader.load(
        "https://gouthsi.github.io/keychain-3d/gill_sans_heavy.typeface.json",    // â† CHANGE THIS
        font => {
            loadedFont = font;
            buildKeychain("Your Name", "#ff0000", "#000000");
        }
    );

    window.addEventListener("resize", onResize);
    animate();
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// -------------------------------------------------------
// BUILD KEYCHAIN MODEL
// -------------------------------------------------------
function buildKeychain(text, topColor, baseColor) {
    if (!loadedFont) return;

    if (keyGroup) {
        scene.remove(keyGroup);
        keyGroup.traverse(o => {
            if (o.geometry) o.geometry.dispose();
            if (o.material) o.material.dispose();
        });
    }

    keyGroup = new THREE.Group();

    const topHeight  = 1.8;
    const baseHeight = 4;
    const fontSize   = 20;

    // create text geometry
    const textGeo = new THREE.TextGeometry(text, {
        font: loadedFont,
        size: fontSize,
        height: topHeight,
        bevelEnabled: true,
        bevelThickness: 0.3,
        bevelSize: 0.22,
        bevelSegments: 3,
        curveSegments: 8
    });

    // center text
    textGeo.computeBoundingBox();
    const bb = textGeo.boundingBox;
    const w  = bb.max.x - bb.min.x;

    const cx = -(bb.max.x + bb.min.x) / 2;
    const cy = -(bb.max.y + bb.min.y) / 2;

    const MAX_W = 150;
    const scaleFactor = MAX_W / w;

    // TOP LAYER
    const topMat = new THREE.MeshPhongMaterial({ color: topColor });
    const topMesh = new THREE.Mesh(textGeo, topMat);
    topMesh.position.set(cx, cy, baseHeight);
    keyGroup.add(topMesh);

    // -------------------------------------------------------
    // SHARP OUTLINE BASE (Clipper)
    // -------------------------------------------------------
    const rawShapes = loadedFont.generateShapes(text, fontSize);

    let borderShapes = [];

    rawShapes.forEach(sh => {
        const expanded = createOutlineShapes(sh, BORDER_MM);
        borderShapes.push(...expanded);
    });

    // extrude base layer
    const baseGeo = new THREE.ExtrudeGeometry(borderShapes, {
        depth: baseHeight,
        bevelEnabled: false,
        curveSegments: 8
    });

    const baseMat = new THREE.MeshPhongMaterial({ color: baseColor });
    const baseMesh = new THREE.Mesh(baseGeo, baseMat);

    // center base
    baseGeo.computeBoundingBox();
    const bb2 = baseGeo.boundingBox;

    const bx = -(bb2.max.x + bb2.min.x) / 2;
    const by = -(bb2.max.y + bb2.min.y) / 2;

    baseMesh.position.set(bx, by, 0);
    keyGroup.add(baseMesh);

    // scale the whole keychain
    keyGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);

    // tilt for visual
    keyGroup.rotation.x = -0.22;

    scene.add(keyGroup);
}

// -------------------------------------------------------
// RECEIVE DATA FROM WIX
// -------------------------------------------------------
window.onmessage = (e) => {
    const d = e.data;
    buildKeychain(
        d.text || "Your Name",
        d.topColor || "#ff0000",
        d.baseColor || "#000000"
    );
};

// -------------------------------------------------------
function animate() {
    requestAnimationFrame(animate);

    if (!interacted && keyGroup)
        keyGroup.rotation.y += 0.01;

    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>



