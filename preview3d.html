<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>3D Keychain Preview</title>
<style>
  body { margin: 0; overflow: hidden; background: #fff; }
  #preview { width: 100vw; height: 100vh; }
</style>
</head>

<body>
<div id="preview"></div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/geometries/TextGeometry.js"></script>

<!-- ClipperJS (for true polygon offset) -->
<script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>

<script>
let scene, camera, renderer, controls;
let keyGroup = null;
let loadedFont = null;
let interacted = false;

const BORDER_MM = 5;          // uniform border thickness
const SCALE_FACTOR = 10;      // Clipper works best with scaled coords

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.set(0, 60, 200);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("preview").appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.addEventListener("start", () => interacted = true);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const d1 = new THREE.DirectionalLight(0xffffff, 0.9);
    d1.position.set(80, 110, 100);
    scene.add(d1);

    const loader = new THREE.FontLoader();
    loader.load(
        "https://gouthsi.github.io/keychain-3d/gill_sans_heavy.typeface.json",   // CHANGE THIS
        font => {
            loadedFont = font;
            buildKeychain("Your Name", "#ff0000", "#000000");
        }
    );

    window.addEventListener("resize", onResize);
    animate();
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}


// ------------------------------------------
// TRUE OUTLINE USING CLIPPER OFFSET
// ------------------------------------------

function createOutlineShapes(shape, offsetAmount) {
    const pts = shape.getPoints(20);

    // convert to clipper format
    const path = pts.map(p => ({ X: p.x * SCALE_FACTOR, Y: p.y * SCALE_FACTOR }));

    const co = new ClipperLib.ClipperOffset(2, 1);
    co.AddPath(path, ClipperLib.JoinType.jtRound, ClipperLib.EndType.etClosedPolygon);

    const solution = new ClipperLib.Paths();
    co.Execute(solution, offsetAmount * SCALE_FACTOR);

    const shapes = [];

    solution.forEach(s => {
        const newPts = s.map(p => new THREE.Vector2(p.X / SCALE_FACTOR, p.Y / SCALE_FACTOR));
        const newShape = new THREE.Shape(newPts);
        shapes.push(newShape);
    });

    return shapes;
}



// ------------------------------------------
// BUILD KEYCHAIN
// ------------------------------------------

function buildKeychain(text, topColor, baseColor) {
    if (!loadedFont) return;

    if (keyGroup) {
        scene.remove(keyGroup);
        keyGroup.traverse(o => {
            if (o.geometry) o.geometry.dispose();
            if (o.material) o.material.dispose();
        });
    }
    keyGroup = new THREE.Group();

    const topH = 1.8;
    const baseH = 4;
    const fontSize = 20;

    // top text
    const textGeo = new THREE.TextGeometry(text, {
        font: loadedFont,
        size: fontSize,
        height: topH,
        bevelEnabled: true,
        bevelThickness: 0.3,
        bevelSize: 0.23,
        bevelSegments: 3,
        curveSegments: 8
    });

    textGeo.computeBoundingBox();
    const bb = textGeo.boundingBox;

    const width = bb.max.x - bb.min.x;
    const cx = -(bb.max.x + bb.min.x) / 2;
    const cy = -(bb.max.y + bb.min.y) / 2;

    const MAX_W = 150;
    const scale = MAX_W / width;

    const textMesh = new THREE.Mesh(
        textGeo,
        new THREE.MeshPhongMaterial({ color: topColor })
    );
    textMesh.position.set(cx, cy, baseH);
    keyGroup.add(textMesh);

    // Real outline generation
    const rawShapes = loadedFont.generateShapes(text, fontSize);
    let finalOutlineShapes = [];

    rawShapes.forEach(sh => {
        const expanded = createOutlineShapes(sh, BORDER_MM);
        finalOutlineShapes.push(...expanded);
    });

    // extrude base layer
    const baseGeo = new THREE.ExtrudeGeometry(finalOutlineShapes, {
        depth: baseH,
        bevelEnabled: false,
        curveSegments: 8,
    });

    const baseMat = new THREE.MeshPhongMaterial({ color: baseColor });
    const baseMesh = new THREE.Mesh(baseGeo, baseMat);

    baseGeo.computeBoundingBox();
    const bb2 = baseGeo.boundingBox;

    const bx = -(bb2.max.x + bb2.min.x) / 2;
    const by = -(bb2.max.y + bb2.min.y) / 2;

    baseMesh.position.set(bx, by, 0);
    keyGroup.add(baseMesh);

    // scale for long names
    keyGroup.scale.set(scale, scale, scale);

    // slight tilt for view only
    keyGroup.rotation.x = -0.2;

    scene.add(keyGroup);
}


// Wix â†’ viewer
window.onmessage = (e) => {
    const d = e.data;
    buildKeychain(
        d.text || "Your Name",
        d.topColor || "#ff0000",
        d.baseColor || "#000000"
    );
};

function animate() {
    requestAnimationFrame(animate);

    if (!interacted && keyGroup) keyGroup.rotation.y += 0.01;

    controls.update();
    renderer.render(scene, camera);
}

init();
</script>

</body>
</html>
